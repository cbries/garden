{"version":3,"sources":["worker.node/slave.js"],"names":[],"mappings":";;;;AAEA,IAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;;AAEzB,IAAI,mBAAmB,GAAG,KAAK,CAAC;AAChC,IAAI,cAAc,GAAG,0BAAW;AAC9B,SAAO,CAAC,KAAK,CAAC,8BAA8B,CAAC,CAAC;CAC/C,CAAC;;AAEF,SAAS,iBAAiB,GAAG;AAC3B,MAAI,mBAAmB,EAAE;AAAE,WAAO;GAAE;;AAEpC,SAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,UAAS,KAAK,EAAE;AAC9C,WAAO,CAAC,IAAI,CAAC;AACX,WAAK,EAAG,EAAE,OAAO,EAAG,KAAK,CAAC,OAAO,EAAE,KAAK,EAAG,KAAK,CAAC,KAAK,EAAE;KACzD,CAAC,CAAC;GACJ,CAAC,CAAC;;AAEH,qBAAmB,GAAG,IAAI,CAAC;CAC5B;;AAGD,SAAS,oBAAoB,CAAC,IAAI,EAAE;AAClC,MAAI,OAAO,GAAG;AACZ,UAAM,EAAN,MAAM;AACN,WAAO,EAAP,OAAO;AACP,iBAAa,EAAb,aAAa;AACb,gBAAY,EAAZ,YAAY;AACZ,UAAM,EAAU,EAAE,OAAO,EAAG,IAAI,EAAE;AAClC,WAAO,EAAP,OAAO;AACP,eAAW,EAAX,WAAW;AACX,cAAU,EAAV,UAAU;GACX,CAAC;;AAEF,IAAE,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AAClC,SAAO,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC;CAC/B;;AAGD,SAAS,kBAAkB,GAAU;oCAAN,IAAI;AAAJ,QAAI;;;AACjC,SAAO,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;CAClC;;AAED,kBAAkB,CAAC,QAAQ,GAAG,YAAkB;qCAAN,IAAI;AAAJ,QAAI;;;AAC5C,MAAI,CAAC,GAAG,EAAE,CAAC;AACX,oBAAkB,kBAAI,IAAI,CAAC,CAAC;CAC7B,CAAC;;AAEF,SAAS,sBAAsB,CAAC,QAAQ,EAAE;AACxC,SAAO,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAR,QAAQ,EAAE,CAAC,CAAC;CAC5B;;AAGD,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,UAAS,IAAI,EAAE;AACnC,MAAI,IAAI,CAAC,YAAY,EAAE;AACrB,kBAAc,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;GACvC;;AAED,MAAI,IAAI,CAAC,YAAY,EAAE;AACrB,kBAAc,GAAG,oBAAoB,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;GAC1E;;AAED,MAAI,IAAI,CAAC,KAAK,EAAE;;;AAGd,qBAAiB,EAAE,CAAC;;AAEpB,kBAAc,CAAC,IAAI,CAAC,KAAK,EAAE,kBAAkB,EAAE,sBAAsB,CAAC,CAAC;GACxE;CACF,CAAC,CAAC","file":"worker.node/slave.js","sourcesContent":["// not using ES6 import/export syntax, since we need to require() in a handler\n// what the ES6 syntax does not permit\nconst vm = require('vm');\n\nlet errorCatcherInPlace = false;\nlet messageHandler = function() {\n  console.error('No thread logic initialized.');    // eslint-disable-line no-console\n};\n\nfunction setupErrorCatcher() {\n  if (errorCatcherInPlace) { return; }\n\n  process.on('uncaughtException', function(error) {\n    process.send({\n      error : { message : error.message, stack : error.stack }\n    });\n  });\n\n  errorCatcherInPlace = true;\n}\n\n\nfunction runAsSandboxedModule(code) {\n  var sandbox = {\n    Buffer,\n    console,\n    clearInterval,\n    clearTimeout,\n    module        : { exports : null },\n    require,\n    setInterval,\n    setTimeout\n  };\n\n  vm.runInNewContext(code, sandbox);\n  return sandbox.module.exports;\n}\n\n\nfunction messageHandlerDone(...args) {\n  process.send({ response: args });\n}\n\nmessageHandlerDone.transfer = function(...args) {\n  args.pop();         // ignore last parameter, since it's only useful for browser code\n  messageHandlerDone(...args);\n};\n\nfunction messageHandlerProgress(progress) {\n  process.send({ progress });\n}\n\n\nprocess.on('message', function(data) {\n  if (data.initByScript) {\n    messageHandler = require(data.script);\n  }\n\n  if (data.initByMethod) {\n    messageHandler = runAsSandboxedModule('module.exports = ' + data.method);\n  }\n\n  if (data.doRun) {\n    // it's a good idea to wait until first thread logic run to set this up,\n    // so initialization errors will be printed to console\n    setupErrorCatcher();\n\n    messageHandler(data.param, messageHandlerDone, messageHandlerProgress);\n  }\n});\n"],"sourceRoot":"/source/"}